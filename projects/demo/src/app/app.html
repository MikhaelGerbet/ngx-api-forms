<div class="demo-container">
  <!-- GitHub Corner -->
  <a href="https://github.com/MikhaelGerbet/ngx-api-forms" class="github-corner" aria-label="View source on GitHub" target="_blank">
    <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#3b82f6; color:#f8fafc; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
      <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
      <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
      <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
    </svg>
  </a>

  <header class="demo-header">
    <h1>ngx-api-forms</h1>
    <p class="tagline">API error parsing library for Angular. Not a display library -- a parsing library.</p>
    <div class="badges">
      <img src="https://img.shields.io/npm/v/ngx-api-forms?style=flat-square" alt="npm version">
      <img src="https://img.shields.io/npm/l/ngx-api-forms?style=flat-square" alt="license">
      <img src="https://img.shields.io/badge/Angular-17%2B-dd0031?style=flat-square&logo=angular" alt="Angular 17+">
      <img src="https://img.shields.io/github/actions/workflow/status/MikhaelGerbet/ngx-api-forms/ci.yml?style=flat-square&label=CI%2FCD" alt="CI/CD">
      <img src="https://img.shields.io/badge/dependencies-0-brightgreen?style=flat-square" alt="Zero dependencies">
      <img src="https://img.shields.io/badge/SSR-Ready-brightgreen?style=flat-square" alt="SSR Ready">
      <img src="https://img.shields.io/badge/i18n-Friendly-blue?style=flat-square" alt="i18n Friendly">
    </div>
  </header>

  <main class="demo-content">
    <!-- The Problem / Solution -->
    <section class="demo-section why-section">
      <h2>The Problem</h2>
      <p>Every Angular app with server-side validation writes ad-hoc parsing code per backend, per form. Libraries like <code>&#64;ngneat/error-tailor</code> handle <em>displaying</em> client-side errors, but nothing parses API responses. That gap is what ngx-api-forms fills.</p>

      <div class="before-after">
        <div class="code-block before-block">
          <div class="code-header">
            <span>Without ngx-api-forms</span>
          </div>
          <pre><code>// Repeated in every component, for every backend
this.http.post('/api', data).subscribe(&#123;
  error: (err) =&gt; &#123;
    const messages = err.error?.message;
    if (Array.isArray(messages)) &#123;
      for (const msg of messages) &#123;
        const ctrl = this.form.get(msg.property);
        if (ctrl) &#123;
          ctrl.setErrors(msg.constraints);
          ctrl.markAsTouched();
        &#125;
      &#125;
    &#125;
    // Switch to Laravel? Rewrite everything.
    // Switch to Django? Rewrite everything.
    // 10 forms? 10 copies.
  &#125;
&#125;);</code></pre>
        </div>
        <div class="code-block after-block">
          <div class="code-header">
            <span>With ngx-api-forms</span>
          </div>
          <pre><code>// Works with any supported backend
this.http.post('/api', data).subscribe(&#123;
  error: (err) =&gt; bridge.applyApiErrors(err.error)
&#125;);

// Or without a form (interceptors, stores, effects):
// parseApiErrors(err.error, laravelPreset());</code></pre>
        </div>
      </div>

      <div class="why-grid">
        <div class="why-card">
          <h3>4 Backend Presets</h3>
          <p>NestJS, Laravel, Django REST, Zod. Same API, different backends. One line to switch.</p>
        </div>
        <div class="why-card">
          <h3>Standalone Parsing</h3>
          <p><code>parseApiErrors()</code> works without a form. Use it in HttpInterceptors, NgRx effects, or services.</p>
        </div>
        <div class="why-card">
          <h3>Native Signals</h3>
          <p>Reactive error state via <code>errorsSignal</code>, <code>firstErrorSignal</code>, <code>hasErrorsSignal</code>.</p>
        </div>
        <div class="why-card">
          <h3>Zero Dependencies</h3>
          <p>Only Angular as peer dependency. Tree-shakeable, SSR-compatible, i18n-ready.</p>
        </div>
      </div>
    </section>

    <!-- Interactive Demo -->
    <section class="demo-section interactive-demo">
      <h2>Interactive Demo</h2>
      <p>Select a backend format and simulate API validation errors on a real Angular form.</p>

      <div class="demo-layout">
        <div class="demo-form-side">
          <h3>Sample Form</h3>
          <form [formGroup]="form" class="sample-form">
            <div class="form-field">
              <label for="email">Email</label>
              <input id="email" type="email" formControlName="email" placeholder="user@example.com">
              <span ngxFormError="email" [form]="form" class="field-error"></span>
            </div>
            <div class="form-field">
              <label for="name">Name</label>
              <input id="name" type="text" formControlName="name" placeholder="John Doe">
              <span ngxFormError="name" [form]="form" class="field-error"></span>
            </div>
            <div class="form-field">
              <label for="age">Age</label>
              <input id="age" type="number" formControlName="age" placeholder="25">
              <span ngxFormError="age" [form]="form" class="field-error"></span>
            </div>
            <div class="form-field">
              <label for="password">Password</label>
              <input id="password" type="password" formControlName="password" placeholder="--------">
              <span ngxFormError="password" [form]="form" class="field-error"></span>
            </div>
          </form>

          <div class="demo-controls">
            <div class="preset-selector">
              <label>Backend format:</label>
              <select [value]="selectedMockKey()" (change)="selectedMockKey.set($any($event.target).value)">
                <option value="class-validator">NestJS / class-validator</option>
                <option value="class-validator-string">NestJS (string message)</option>
                <option value="laravel">Laravel</option>
                <option value="django">Django REST</option>
                <option value="zod">Zod (flattened)</option>
                <option value="zod-issues">Zod (issues)</option>
              </select>
            </div>
            <div class="demo-buttons">
              <button class="btn btn-primary" (click)="simulateApiError()">Simulate API Error</button>
              <button class="btn btn-secondary" (click)="clearErrors()">Clear Errors</button>
              <button class="btn btn-ghost" (click)="resetForm()">Reset Form</button>
            </div>
          </div>
        </div>

        <div class="demo-result-side">
          <h3>Form Errors State</h3>
          <div class="result-panel">
            <pre><code>{{ formErrorsDisplay() }}</code></pre>
          </div>

          @if (lastResult()) {
            <h3>Resolved Errors (from FormBridge)</h3>
            <div class="result-panel resolved">
              <pre><code>{{ lastResult() }}</code></pre>
            </div>
          }

          <h3>Signals</h3>
          <div class="signals-panel">
            <div class="signal-row">
              <span class="signal-label">hasErrors:</span>
              <span class="signal-value" [class.active]="bridge.hasErrorsSignal()">{{ bridge.hasErrorsSignal() }}</span>
            </div>
            <div class="signal-row">
              <span class="signal-label">firstError:</span>
              <span class="signal-value">{{ bridge.firstErrorSignal()?.field ?? 'null' }}</span>
            </div>
            <div class="signal-row">
              <span class="signal-label">errorsCount:</span>
              <span class="signal-value">{{ bridge.errorsSignal().length }}</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Implementation Code -->
      <div class="code-tabs">
        <h3>Implementation</h3>
        <div class="code-block">
          <div class="code-header">
            <span>component.ts</span>
            <button class="copy-btn" (click)="copyToClipboard('bridge = provideFormBridge(this.form, {\n  preset: classValidatorPreset(),\n});\n\nsimulateApiError(): void {\n  const result = this.bridge.applyApiErrors(apiResponse);\n}')">Copy</button>
          </div>
          <pre><code>bridge = provideFormBridge(this.form, &#123;
  preset: classValidatorPreset(),
&#125;);

simulateApiError(): void &#123;
  const result = this.bridge.applyApiErrors(apiResponse);
  // result: ResolvedFieldError[] - all mapped errors
&#125;</code></pre>
        </div>
        <div class="code-block">
          <div class="code-header">
            <span>template.html</span>
            <button class="copy-btn" (click)="copyToClipboard('<input formControlName=&quot;email&quot; />\n<span ngxFormError=&quot;email&quot; [form]=&quot;form&quot;></span>')">Copy</button>
          </div>
          <pre><code>&lt;input formControlName="email" /&gt;
&lt;span ngxFormError="email" [form]="form"&gt;&lt;/span&gt;

&lt;!-- The directive displays the first error automatically --&gt;
&lt;!-- Visible only when the control is touched or dirty --&gt;</code></pre>
        </div>
      </div>
    </section>

    <!-- Submit / Loading State Demo -->
    <section class="demo-section submit-demo">
      <h2>Submit and Loading State</h2>
      <p>The standalone <code>wrapSubmit()</code> function handles form disable/enable lifecycle. Pair it with a local signal to track loading state.</p>

      <div class="demo-layout">
        <div class="demo-form-side">
          <h3>Form with Submit</h3>
          <form [formGroup]="submitForm" class="sample-form">
            <div class="form-field">
              <label for="submit-email">Email</label>
              <input id="submit-email" type="email" formControlName="email">
              <span ngxFormError="email" [form]="submitForm" class="field-error"></span>
            </div>
            <div class="form-field">
              <label for="submit-name">Name</label>
              <input id="submit-name" type="text" formControlName="name">
              <span ngxFormError="name" [form]="submitForm" class="field-error"></span>
            </div>
          </form>

          <div class="demo-controls">
            <div class="toggle-row">
              <label>
                <input type="checkbox" [checked]="submitShouldFail()" (change)="submitShouldFail.set($any($event.target).checked)">
                Simulate failure (returns validation errors)
              </label>
            </div>
            <div class="demo-buttons">
              <button class="btn btn-primary" (click)="simulateSubmit()" [disabled]="isSubmitting()">
                @if (isSubmitting()) {
                  Sending...
                } @else {
                  Submit
                }
              </button>
            </div>
          </div>
        </div>

        <div class="demo-result-side">
          <h3>State</h3>
          <div class="signals-panel">
            <div class="signal-row">
              <span class="signal-label">isSubmitting:</span>
              <span class="signal-value" [class.active]="isSubmitting()">{{ isSubmitting() }}</span>
            </div>
            <div class="signal-row">
              <span class="signal-label">hasErrors:</span>
              <span class="signal-value" [class.active]="submitBridge.hasErrorsSignal()">{{ submitBridge.hasErrorsSignal() }}</span>
            </div>
            <div class="signal-row">
              <span class="signal-label">form.disabled:</span>
              <span class="signal-value" [class.active]="submitForm.disabled">{{ submitForm.disabled }}</span>
            </div>
          </div>
          @if (submitResult()) {
            <h3>Result</h3>
            <div class="result-panel" [class.resolved]="submitShouldFail()">
              <pre><code>{{ submitResult() }}</code></pre>
            </div>
          }
        </div>
      </div>

      <div class="code-tabs">
        <h3>Implementation</h3>
        <div class="code-block">
          <div class="code-header">
            <span>component.ts</span>
            <button class="copy-btn" (click)="copyToClipboard('import { wrapSubmit } from \'ngx-api-forms\';\n\nonSubmit() {\n  this.isSubmitting.set(true);\n  wrapSubmit(this.form, this.http.post(\'/api/save\', this.form.value), {\n    onError: (err) => this.bridge.applyApiErrors(err.error),\n  }).subscribe({\n    next: () => { this.isSubmitting.set(false); },\n    error: () => { this.isSubmitting.set(false); },\n  });\n}')">Copy</button>
          </div>
          <pre><code>import &#123; wrapSubmit &#125; from 'ngx-api-forms';

onSubmit() &#123;
  this.isSubmitting.set(true);
  wrapSubmit(this.form,
    this.http.post('/api/save', this.form.value),
    &#123; onError: (err) =&gt; this.bridge.applyApiErrors(err.error) &#125;
  ).subscribe(&#123;
    next: () =&gt; this.isSubmitting.set(false),
    error: () =&gt; this.isSubmitting.set(false),
  &#125;);
&#125;</code></pre>
        </div>
        <div class="code-block">
          <div class="code-header">
            <span>template.html</span>
            <button class="copy-btn" (click)="copyToClipboard('<button [disabled]=&quot;isSubmitting()&quot;>\n  @if (isSubmitting()) {\n    Sending...\n  } @else {\n    Submit\n  }\n</button>')">Copy</button>
          </div>
          <pre><code>&lt;button [disabled]="isSubmitting()"&gt;
  &#64;if (isSubmitting()) &#123;
    Sending...
  &#125; &#64;else &#123;
    Submit
  &#125;
&lt;/button&gt;</code></pre>
        </div>
      </div>
    </section>

    <!-- i18n Demo -->
    <section class="demo-section i18n-demo">
      <h2>Internationalization (i18n)</h2>
      <p>API errors often come in English from the backend. The library supports two approaches for translating them.</p>

      <div class="demo-layout">
        <div class="demo-form-side">
          <h3>i18n Form</h3>
          <form [formGroup]="i18nForm" class="sample-form">
            <div class="form-field">
              <label for="i18n-email">Email</label>
              <input id="i18n-email" type="text" formControlName="email">
              <span ngxFormError="email" [form]="i18nForm" class="field-error"></span>
            </div>
            <div class="form-field">
              <label for="i18n-name">Name</label>
              <input id="i18n-name" type="text" formControlName="name">
              <span ngxFormError="name" [form]="i18nForm" class="field-error"></span>
            </div>
          </form>

          <div class="demo-controls">
            <div class="toggle-group">
              <button class="btn" [class.btn-primary]="i18nMode() === 'prefix'" [class.btn-ghost]="i18nMode() !== 'prefix'" (click)="i18nMode.set('prefix')">Key Prefix</button>
              <button class="btn" [class.btn-primary]="i18nMode() === 'resolver'" [class.btn-ghost]="i18nMode() !== 'resolver'" (click)="i18nMode.set('resolver')">Custom Resolver</button>
            </div>
            <div class="demo-buttons">
              <button class="btn btn-primary" (click)="simulateI18n()">Apply i18n Errors</button>
            </div>
          </div>
        </div>

        <div class="demo-result-side">
          <h3>How it works</h3>
          @if (i18nMode() === 'prefix') {
            <div class="info-box">
              <p>With <code>i18n.prefix</code>, error messages become translation keys:</p>
              <p><code>"email must be valid"</code> becomes <code>"validation.email.isEmail"</code></p>
              <p>Feed these keys to your i18n library (ngx-translate, transloco, etc).</p>
            </div>
          } @else {
            <div class="info-box">
              <p>With <code>i18n.resolver</code>, you provide a callback that returns the translated message:</p>
              <p><code>"email.isEmail"</code> resolves to <code>"L'email n'est pas valide"</code></p>
              <p>Full control over the translation logic.</p>
            </div>
          }

          @if (i18nResult()) {
            <h3>Resolved Errors</h3>
            <div class="result-panel resolved">
              <pre><code>{{ i18nResult() }}</code></pre>
            </div>
          }
        </div>
      </div>

      <div class="code-tabs">
        <h3>Implementation</h3>
        @if (i18nMode() === 'prefix') {
          <div class="code-block">
            <div class="code-header">
              <span>Prefix mode</span>
              <button class="copy-btn" (click)="copyToClipboard('bridge = provideFormBridge(this.form, {\n  preset: classValidatorPreset(),\n  i18n: { prefix: \'validation\' },\n});')">Copy</button>
            </div>
            <pre><code>bridge = provideFormBridge(this.form, &#123;
  preset: classValidatorPreset(),
  i18n: &#123; prefix: 'validation' &#125;,
&#125;);

// Error messages become keys like:
//   "validation.email.isEmail"
//   "validation.name.isNotEmpty"
// Use with your i18n pipe or service</code></pre>
          </div>
        } @else {
          <div class="code-block">
            <div class="code-header">
              <span>Resolver mode</span>
              <button class="copy-btn" (click)="copyToClipboard('bridge = provideFormBridge(this.form, {\n  preset: classValidatorPreset(),\n  i18n: {\n    resolver: (field, constraint, originalMessage) => {\n      return this.translate.instant(`errors.${field}.${constraint}`);\n    },\n  },\n});')">Copy</button>
            </div>
            <pre><code>bridge = provideFormBridge(this.form, &#123;
  preset: classValidatorPreset(),
  i18n: &#123;
    resolver: (field, constraint, originalMessage) =&gt; &#123;
      // Use any i18n service here
      return this.translate.instant(`errors.$&#123;field&#125;.$&#123;constraint&#125;`);
    &#125;,
  &#125;,
&#125;);</code></pre>
          </div>
        }
      </div>
    </section>

    <!-- Dirty State & Interceptors Demo -->
    <section class="demo-section dirty-demo">
      <h2>Dirty State & Interceptors</h2>
      <p>Track form modifications with Angular's built-in <code>form.dirty</code> or the standalone <code>getDirtyValues()</code>. Interceptors can filter or transform errors before they reach the form, and return a dispose function.</p>

      <div class="demo-layout">
        <div class="demo-form-side">
          <h3>Dirty Tracking</h3>
          <form [formGroup]="dirtyForm" class="sample-form">
            <div class="form-field">
              <label for="dirty-email">Email (default: user&#64;test.com)</label>
              <input id="dirty-email" type="email" formControlName="email">
            </div>
            <div class="form-field">
              <label for="dirty-name">Name (default: John)</label>
              <input id="dirty-name" type="text" formControlName="name">
            </div>
          </form>

          <div class="demo-controls">
            <div class="demo-buttons">
              <button class="btn btn-secondary" (click)="dirtyForm.reset({email: 'user@test.com', name: 'John'}); dirtyBridge.clearApiErrors()">Reset to Defaults</button>
              <button class="btn btn-ghost" (click)="toggleInterceptor()">
                {{ interceptorActive() ? 'Remove Interceptor' : 'Add Interceptor (filter email)' }}
              </button>
              <button class="btn btn-primary" (click)="applyDirtyErrors()">Apply Errors</button>
            </div>
          </div>
        </div>

        <div class="demo-result-side">
          <h3>State</h3>
          <div class="signals-panel">
            <div class="signal-row">
              <span class="signal-label">form.dirty:</span>
              <span class="signal-value" [class.active]="dirtyForm.dirty">{{ dirtyForm.dirty }}</span>
            </div>
            <div class="signal-row">
              <span class="signal-label">hasErrors:</span>
              <span class="signal-value" [class.active]="dirtyBridge.hasErrorsSignal()">{{ dirtyBridge.hasErrorsSignal() }}</span>
            </div>
            <div class="signal-row">
              <span class="signal-label">interceptor active:</span>
              <span class="signal-value" [class.active]="interceptorActive()">{{ interceptorActive() }}</span>
            </div>
          </div>

          <div class="info-box">
            <p>Use Angular's built-in <code>form.dirty</code> for simple dirty tracking, or <code>getDirtyValues(form)</code> to get only the changed fields.</p>
            <p>When the interceptor is active, email errors are filtered out. Use the dispose function to remove it.</p>
          </div>
        </div>
      </div>

      <div class="code-tabs">
        <h3>Implementation</h3>
        <div class="code-block">
          <div class="code-header">
            <span>component.ts</span>
            <button class="copy-btn" (click)="copyToClipboard('// Dirty tracking with built-in Angular API\nconst isDirty = this.form.dirty;\n\n// Or get only changed values:\nimport { getDirtyValues } from \'ngx-api-forms\';\nconst changed = getDirtyValues(this.form);\n\n// Interceptors return a dispose function\nconst dispose = bridge.addInterceptor((errors) =>\n  errors.filter(e => e.field !== \'email\')\n);\n// Later: dispose() to remove the interceptor')">Copy</button>
          </div>
          <pre><code>// Dirty tracking with built-in Angular API
const isDirty = this.form.dirty;

// Or get only changed values:
import &#123; getDirtyValues &#125; from 'ngx-api-forms';
const changed = getDirtyValues(this.form);

// Interceptors return a dispose function
const dispose = bridge.addInterceptor((errors) =&gt;
  errors.filter(e =&gt; e.field !== 'email')
);
// Later: dispose() to remove the interceptor</code></pre>
        </div>
      </div>
    </section>

    <!-- Standalone Parsing Demo -->
    <section class="demo-section standalone-demo">
      <h2>Standalone Parsing</h2>
      <p><code>parseApiErrors()</code> parses API error bodies without a form or a FormBridge. Use it in HttpInterceptors, NgRx effects, services, or anywhere you need structured errors.</p>

      <div class="demo-layout">
        <div class="demo-form-side">
          <h3>No form needed</h3>
          <div class="info-box">
            <p>This demo calls <code>parseApiErrors(error, preset)</code> directly. No <code>FormGroup</code>, no <code>FormBridge</code>. The function returns a normalized <code>ApiFieldError[]</code> regardless of the backend format.</p>
          </div>

          <div class="demo-controls">
            <div class="preset-selector">
              <label>Backend format:</label>
              <select [value]="standalonePreset()" (change)="standalonePreset.set($any($event.target).value)">
                <option value="class-validator">NestJS / class-validator</option>
                <option value="laravel">Laravel</option>
                <option value="django">Django REST</option>
                <option value="zod">Zod</option>
              </select>
            </div>
            <div class="demo-buttons">
              <button class="btn btn-primary" (click)="simulateStandaloneParsing()">Parse Errors</button>
              <button class="btn btn-secondary" (click)="standaloneResult.set('')">Clear</button>
            </div>
          </div>
        </div>

        <div class="demo-result-side">
          <h3>Parsed Output</h3>
          @if (standaloneResult()) {
            <div class="result-panel resolved">
              <pre><code>{{ standaloneResult() }}</code></pre>
            </div>
          } @else {
            <div class="info-box">
              <p>Select a backend format and click "Parse Errors" to see the normalized output.</p>
            </div>
          }
        </div>
      </div>

      <div class="code-tabs">
        <h3>Implementation</h3>
        <div class="code-block">
          <div class="code-header">
            <span>interceptor.ts</span>
            <button class="copy-btn" (click)="copyToClipboard('import { HttpInterceptorFn } from \'@angular/common/http\';\nimport { parseApiErrors, classValidatorPreset } from \'ngx-api-forms\';\n\nexport const apiErrorInterceptor: HttpInterceptorFn = (req, next) => {\n  return next(req).pipe(\n    catchError((err) => {\n      if (err.status === 422) {\n        const errors = parseApiErrors(err.error, classValidatorPreset());\n        errorStore.setFieldErrors(errors);\n      }\n      return throwError(() => err);\n    }),\n  );\n};')">Copy</button>
          </div>
          <pre><code>import &#123; HttpInterceptorFn &#125; from '&#64;angular/common/http';
import &#123; parseApiErrors, classValidatorPreset &#125; from 'ngx-api-forms';

export const apiErrorInterceptor: HttpInterceptorFn = (req, next) =&gt; &#123;
  return next(req).pipe(
    catchError((err) =&gt; &#123;
      if (err.status === 422) &#123;
        const errors = parseApiErrors(err.error, classValidatorPreset());
        errorStore.setFieldErrors(errors);
      &#125;
      return throwError(() =&gt; err);
    &#125;),
  );
&#125;;</code></pre>
        </div>
      </div>
    </section>

    <!-- Custom JSON Demo -->
    <section class="demo-section custom-demo">
      <h2>Custom Error Payload</h2>
      <p>Paste your own API error response below and see how the library parses it.</p>

      <div class="demo-layout">
        <div class="demo-form-side">
          <h3>Your JSON Payload</h3>
          <textarea class="json-input" [value]="customJson()" (input)="customJson.set($any($event.target).value)" rows="10" spellcheck="false"></textarea>

          <div class="demo-controls">
            <div class="preset-selector">
              <label>Preset:</label>
              <select [value]="customPreset()" (change)="customPreset.set($any($event.target).value)">
                <option value="class-validator">NestJS / class-validator</option>
                <option value="laravel">Laravel</option>
                <option value="django">Django REST</option>
                <option value="zod">Zod</option>
              </select>
            </div>
            <div class="demo-buttons">
              <button class="btn btn-primary" (click)="applyCustomJson()">Parse and Apply</button>
              <button class="btn btn-secondary" (click)="clearCustom()">Clear</button>
            </div>
          </div>
        </div>

        <div class="demo-result-side">
          <h3>Target Form</h3>
          <form [formGroup]="customJsonForm" class="sample-form">
            <div class="form-field">
              <label>email</label>
              <input type="text" formControlName="email" readonly>
              <span ngxFormError="email" [form]="customJsonForm" class="field-error"></span>
            </div>
            <div class="form-field">
              <label>name</label>
              <input type="text" formControlName="name" readonly>
              <span ngxFormError="name" [form]="customJsonForm" class="field-error"></span>
            </div>
            <div class="form-field">
              <label>age</label>
              <input type="number" formControlName="age" readonly>
              <span ngxFormError="age" [form]="customJsonForm" class="field-error"></span>
            </div>
            <div class="form-field">
              <label>password</label>
              <input type="text" formControlName="password" readonly>
              <span ngxFormError="password" [form]="customJsonForm" class="field-error"></span>
            </div>
          </form>

          @if (customResult()) {
            <h3>Parsed Result</h3>
            <div class="result-panel resolved">
              <pre><code>{{ customResult() }}</code></pre>
            </div>
          }
        </div>
      </div>
    </section>

    <!-- Mock API Payloads -->
    <section class="demo-section payloads-section">
      <h2>API Error Payloads (Mock)</h2>
      <p>These are the exact error shapes each backend returns. ngx-api-forms parses them all automatically.</p>

      <div class="payloads-grid">
        <div class="payload-card">
          <h4>NestJS / class-validator</h4>
          <pre><code>{{mockErrors['class-validator'] | json}}</code></pre>
        </div>
        <div class="payload-card">
          <h4>Laravel</h4>
          <pre><code>{{mockErrors['laravel'] | json}}</code></pre>
        </div>
        <div class="payload-card">
          <h4>Django REST</h4>
          <pre><code>{{mockErrors['django'] | json}}</code></pre>
        </div>
        <div class="payload-card">
          <h4>Zod (flattened)</h4>
          <pre><code>{{mockErrors['zod'] | json}}</code></pre>
        </div>
      </div>
    </section>

    <!-- Installation -->
    <section class="demo-section installation">
      <h2>Installation</h2>
      <div class="code-block">
        <div class="code-header">
          <span>npm</span>
          <button class="copy-btn" (click)="copyToClipboard('npm install ngx-api-forms')">Copy</button>
        </div>
        <pre><code>npm install ngx-api-forms</code></pre>
      </div>
      <div class="code-block">
        <div class="code-header">
          <span>ng add</span>
          <button class="copy-btn" (click)="copyToClipboard('ng add ngx-api-forms --preset=laravel')">Copy</button>
        </div>
        <pre><code>ng add ngx-api-forms --preset=laravel
# Options: laravel, django, express-validator, spring</code></pre>
      </div>
    </section>

    <!-- Quick Start -->
    <section class="demo-section quick-start">
      <h2>Quick Start</h2>

      <div class="code-block">
        <div class="code-header"><span>component.ts</span></div>
        <pre><code>import &#123; provideFormBridge, classValidatorPreset &#125; from 'ngx-api-forms';

export class MyComponent &#123;
  form = inject(FormBuilder).group(&#123;
    email: ['', Validators.required],
    name: ['', Validators.minLength(3)],
  &#125;);

  bridge = provideFormBridge(this.form, &#123;
    preset: classValidatorPreset(),
  &#125;);

  onSubmit() &#123;
    this.http.post('/api', this.form.value).subscribe(&#123;
      error: (err) =&gt; this.bridge.applyApiErrors(err.error),
    &#125;);
  &#125;
&#125;</code></pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span>template.html</span></div>
        <pre><code>&lt;form [formGroup]="form" (ngSubmit)="onSubmit()"&gt;
  &lt;input formControlName="email" /&gt;
  &lt;span ngxFormError="email" [form]="form"&gt;&lt;/span&gt;

  &lt;input formControlName="name" /&gt;
  &lt;span ngxFormError="name" [form]="form"&gt;&lt;/span&gt;

  &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre>
      </div>
    </section>

    <!-- API Reference -->
    <section class="demo-section api-ref">
      <h2>API Reference</h2>

      <h3>FormBridge (core)</h3>
      <p style="margin-bottom: 0.5rem; color: var(--text-secondary, #94a3b8); font-size: 0.9rem;">Create with <code>provideFormBridge(form, config?)</code> or <code>createFormBridge(form, config?)</code>. Both are equivalent.</p>
      <div class="api-table-wrapper">
        <table class="api-table">
          <thead>
            <tr><th>Method</th><th>Returns</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr><td><code>applyApiErrors(error)</code></td><td><code>ResolvedFieldError[]</code></td><td>Parse and apply API errors to form controls</td></tr>
            <tr><td><code>clearApiErrors()</code></td><td><code>void</code></td><td>Clear all API errors, restore client validation</td></tr>
            <tr><td><code>getFirstError()</code></td><td><code>FirstError | null</code></td><td>Get the first error across all controls</td></tr>
            <tr><td><code>getFieldErrors(field)</code></td><td><code>ValidationErrors | null</code></td><td>Get errors for a specific field</td></tr>
            <tr><td><code>addInterceptor(fn)</code></td><td><code>() =&gt; void</code></td><td>Register an error interceptor, returns a dispose function</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Signals</h3>
      <div class="api-table-wrapper">
        <table class="api-table">
          <thead>
            <tr><th>Signal</th><th>Type</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr><td><code>errorsSignal</code></td><td><code>Signal&lt;ResolvedFieldError[]&gt;</code></td><td>All current API errors</td></tr>
            <tr><td><code>firstErrorSignal</code></td><td><code>Signal&lt;FirstError | null&gt;</code></td><td>First error or null</td></tr>
            <tr><td><code>hasErrorsSignal</code></td><td><code>Signal&lt;boolean&gt;</code></td><td>Whether any API errors exist</td></tr>
          </tbody>
        </table>
      </div>

      <h3>Presets</h3>
      <div class="api-table-wrapper">
        <table class="api-table">
          <thead>
            <tr><th>Function</th><th>Backend</th><th>Error format</th></tr>
          </thead>
          <tbody>
            <tr><td><code>classValidatorPreset()</code></td><td>NestJS / class-validator</td><td><code>&#123; message: [&#123; property, constraints &#125;] &#125;</code></td></tr>
            <tr><td><code>laravelPreset()</code></td><td>Laravel</td><td><code>&#123; errors: &#123; field: [msgs] &#125; &#125;</code></td></tr>
            <tr><td><code>djangoPreset()</code></td><td>Django REST</td><td><code>&#123; field: [msgs] &#125;</code></td></tr>
            <tr><td><code>zodPreset()</code></td><td>Zod</td><td><code>&#123; fieldErrors: &#123;...&#125; &#125;</code> or <code>&#123; issues: [...] &#125;</code></td></tr>
          </tbody>
        </table>
      </div>

      <h3>Standalone Functions</h3>
      <div class="api-table-wrapper">
        <table class="api-table">
          <thead>
            <tr><th>Function</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr><td><code>parseApiErrors(error, preset?)</code></td><td>Parse API errors without a form. Works in interceptors, stores, effects.</td></tr>
            <tr><td><code>wrapSubmit(form, source, opts?)</code></td><td>Submit lifecycle (disable/enable) without FormBridge.</td></tr>
            <tr><td><code>toFormData(data)</code></td><td>Convert a plain object to FormData (Files, Blobs, Arrays, nested objects).</td></tr>
            <tr><td><code>enableForm(form, opts?)</code></td><td>Enable all controls, with optional <code>except</code> list.</td></tr>
            <tr><td><code>disableForm(form, opts?)</code></td><td>Disable all controls, with optional <code>except</code> list.</td></tr>
            <tr><td><code>clearFormErrors(form)</code></td><td>Clear all errors from all controls.</td></tr>
            <tr><td><code>getDirtyValues(form)</code></td><td>Return only dirty fields and their values.</td></tr>
            <tr><td><code>hasError(form, errorKey)</code></td><td>Check if any control has a specific error.</td></tr>
            <tr><td><code>getErrorMessage(form, field, key?)</code></td><td>Get the error message string for a field.</td></tr>
          </tbody>
        </table>
      </div>

      <h3>i18n Configuration</h3>
      <div class="api-table-wrapper">
        <table class="api-table">
          <thead>
            <tr><th>Option</th><th>Type</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr><td><code>i18n.prefix</code></td><td><code>string</code></td><td>Prefix for translation keys (e.g. "validation" produces "validation.email.isEmail")</td></tr>
            <tr><td><code>i18n.resolver</code></td><td><code>(field, constraint, msg) =&gt; string | null</code></td><td>Custom resolver function for full control over translation</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- Compatibility -->
    <section class="demo-section compatibility">
      <h2>Angular Compatibility</h2>
      <table class="compat-table">
        <thead>
          <tr><th>ngx-api-forms</th><th>Angular</th></tr>
        </thead>
        <tbody>
          <tr><td>1.x</td><td>17.x, 18.x, 19.x, 20.x</td></tr>
        </tbody>
      </table>
    </section>
  </main>

  <footer class="demo-footer">
    <div class="footer-links">
      <a href="https://github.com/MikhaelGerbet/ngx-api-forms" target="_blank">GitHub</a>
      <a href="https://www.npmjs.com/package/ngx-api-forms" target="_blank">npm</a>
    </div>
    <p>ngx-api-forms &copy; {{ currentYear }} <a href="https://github.com/MikhaelGerbet" target="_blank">Mikha&euml;l GERBET</a> | MIT License</p>
  </footer>
</div>
